import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import org.jetbrains.dokka.gradle.DokkaTask
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.openstreetmap.josm.gradle.plugin.GitDescriber
import org.openstreetmap.josm.gradle.plugin.api.gitlab.gitlabRepository
import org.openstreetmap.josm.gradle.plugin.logCoverage
import org.openstreetmap.josm.gradle.plugin.logPublishedMavenArtifacts
import org.openstreetmap.josm.gradle.plugin.logSkippedTasks
import org.openstreetmap.josm.gradle.plugin.logTaskDuration
import org.openstreetmap.josm.gradle.plugin.task.gitlab.ReleaseToGitlab
import java.net.URL

plugins {
  id("com.gradle.plugin-publish").version("0.11.0")
  id("com.github.ben-manes.versions").version("0.28.0")
  id("org.jetbrains.dokka").version(Versions.dokka)
  kotlin("jvm").version(Versions.kotlin)
  kotlin("plugin.serialization").version(Versions.kotlin)

  jacoco
  `java-gradle-plugin`
  `maven-publish`
}

// Logging
gradle.taskGraph.logPublishedMavenArtifacts()
gradle.taskGraph.logTaskDuration()
logSkippedTasks()

allprojects {
  afterEvaluate {
    tasks.withType(JacocoReport::class) {
      logCoverage()
    }
  }
  group = "org.openstreetmap.josm"
  version = GitDescriber(rootProject.projectDir).describe(trimLeading = true)

  pluginManager.withPlugin("java") {
    java.sourceCompatibility = JavaVersion.VERSION_1_8
  }

  repositories {
    jcenter()
  }

  tasks.withType(KotlinCompile::class) {
    kotlinOptions.jvmTarget = JavaVersion.VERSION_1_8.toString()
  }

  tasks.withType(Test::class) {
    useJUnitPlatform()
  }

  this.extensions.findByType(JacocoPluginExtension::class)?.apply {
    toolVersion = Versions.jacoco
  }
}

afterEvaluate {
  // use Javadoc generated by Dokka
  tasks.named<Jar>("publishPluginJavaDocsJar") {
    from(provider { tasks.dokka })
  }
}

val dogfood by sourceSets.registering

tasks.jar {
  from(project.provider { project(":i18n").sourceSets.main.map { it.output } })
  from(dogfood.map { it.output })
}

dependencies {
  dogfood.configure {

    add(apiConfigurationName, "org.eclipse.jgit:org.eclipse.jgit:${Versions.jgit}")
    add(implementationConfigurationName, "org.jetbrains.kotlinx:kotlinx-serialization-runtime:${Versions.kotlinSerialization}")
    add(implementationConfigurationName, gradleApi())
    add(implementationConfigurationName, kotlin("stdlib"))
  }

  implementation("com.squareup.okhttp3", "okhttp", Versions.okhttp)
  implementation("com.beust","klaxon", Versions.klaxon)
  implementation("com.fasterxml.jackson.module", "jackson-module-kotlin", Versions.jackson)
  implementation("com.fasterxml.jackson.dataformat", "jackson-dataformat-yaml", Versions.jackson)
  implementation("com.vladsch.flexmark:flexmark:${Versions.flexmark}")

  testImplementation("org.junit.jupiter", "junit-jupiter-api", Versions.junit)
  testImplementation("org.junit.jupiter", "junit-jupiter-params", Versions.junit)
  testImplementation("com.github.tomakehurst","wiremock",Versions.wiremock)
  testImplementation("ru.lanwen.wiremock", "wiremock-junit5", Versions.wiremockJunit5)
  testRuntimeOnly("org.junit.jupiter", "junit-jupiter-engine", Versions.junit)

  project.project(":i18n").pluginManager.withPlugin("java") {
    implementation(project.project(":i18n").sourceSets.main.get().output)
  }
  implementation(dogfood.get().output)

  // Add dependencies of dogfood source set
  api(configurations.getByName(dogfood.get().apiConfigurationName))
  implementation(configurations.getByName(dogfood.get().implementationConfigurationName))
}

// Configure "dokka" task
val dokkaTask: DokkaTask = tasks.withType(DokkaTask::class).getByName("dokka") {
  outputFormat = "html"
  outputDirectory = "$buildDir/docs/kdoc"
}

// Configure all Dokka tasks
tasks.withType(DokkaTask::class) {
  configuration {
    kotlin.sourceSets.named(dogfood.name) {
      //sourceRoots.addAll(this.kotlin.srcDirs.map { srcDir -> GradleSourceRootImpl().also { it.path = srcDir.path } })
    }
    includes = listOf("src/main/kotlin/packages.md")
    jdkVersion = 8
    skipEmptyPackages = false

    externalDocumentationLink {
      url = URL("https://docs.gradle.org/${project.gradle.gradleVersion}/javadoc/")
      packageListUrl = URL("https://docs.gradle.org/${project.gradle.gradleVersion}/javadoc/package-list")
    }
    externalDocumentationLink {
      url = URL("https://docs.groovy-lang.org/next/html/api/")
      packageListUrl = URL("http://docs.groovy-lang.org/next/html/api/package-list")
    }
  }
}

// for the plugin-publish (publish to plugins.gradle.org)
pluginBundle {
  website = "https://gitlab.com/floscher/gradle-josm-plugin#readme"
  vcsUrl = "https://gitlab.com/floscher/gradle-josm-plugin.git"
  description = "This plugin helps with developing for the JOSM project."
  tags = listOf("josm", "openstreetmap", "osm")

  plugins.create("josmPlugin") {
    id = project.group.toString()
    displayName = "Gradle JOSM plugin"
  }
}
// for the java-gradle-plugin (local publishing)
gradlePlugin {
  plugins.create("josmPlugin") {
    id = project.group.toString()
    implementationClass = "org.openstreetmap.josm.gradle.plugin.JosmPlugin"
  }
}

val buildDirRepo = publishing.repositories.maven("$buildDir/maven") {
  name = "buildDir"
}

val awsAccessKeyId: String? = System.getenv("AWS_ACCESS_KEY_ID")
val awsSecretAccessKey: String? = System.getenv("AWS_SECRET_ACCESS_KEY")
val s3Repo = if (awsAccessKeyId == null || awsSecretAccessKey == null) {
  logger.lifecycle(
    "Note: If you want to be able to publish the plugin to s3://gradle-josm-plugin , set the environment variables AWS_ACCESS_KEY_ID ({} set) and AWS_SECRET_ACCESS_KEY ({} set).",
    if (awsAccessKeyId == null) { "not" } else { "is" },
    if (awsSecretAccessKey == null) { "not" } else { "is" }
  )
  null
} else {
  publishing.repositories.maven("s3://gradle-josm-plugin") {
    name = "s3"
    credentials(AwsCredentials::class.java) {
      accessKey = awsAccessKeyId
      secretKey = awsSecretAccessKey
    }
  }
}

// Create GitLab Maven repository to publish to.
publishing.repositories.gitlabRepository("gitlab", project.logger)

// Create `releaseToGitlab` task that can publish a release based on a Gitlab Maven package for a tag.
val releaseToGitlab = tasks.create(
  "releaseToGitlab",
  ReleaseToGitlab::class,
  { true },
  setOf("org/openstreetmap/josm/gradle-josm-plugin", "org/openstreetmap/josm/langconv")
)

tasks.withType<DependencyUpdatesTask> {
  rejectVersionIf {
    listOf("release", "final", "ga").none { candidate.version.toLowerCase().contains(it) } && !"^[0-9,.v-]+(-r)?$".toRegex().matches(candidate.version)
  }
}

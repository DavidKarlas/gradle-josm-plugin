import groovy.lang.GroovySystem
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.api.Git
import org.jetbrains.dokka.DokkaConfiguration
import org.jetbrains.dokka.gradle.DokkaTask
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.openstreetmap.josm.gradle.plugin.GitDescriber

import java.time.Duration
import java.time.Instant
import java.net.URL
import java.util.Locale

buildscript {
  repositories {
    jcenter()
  }
  dependencies {
    val kotlinVersion: String by project.project(":buildSrc").extra
    classpath(kotlin("gradle-plugin", kotlinVersion))
  }
}

plugins {
  id("com.gradle.plugin-publish").version("0.10.0")
  id("com.github.ben-manes.versions").version("0.20.0")
  id("org.jetbrains.dokka").version("0.9.17")

  jacoco
  maven
  eclipse
  `java-gradle-plugin`
  `maven-publish`
}

apply(plugin = "kotlin")
gradle.taskGraph.beforeTask {
  val startTime by this.extra { Instant.now() }
}

gradle.taskGraph.afterTask {
  if (!state.skipped) {
    val startTime: Instant by this.extra
    project.logger.lifecycle(String.format("  üèÅ Finished after %.3f seconds.", Duration.between(startTime, Instant.now()).toMillis() / 1e3))
  }
}

gradle.buildFinished {
  var wereTasksSkipped = false
  tasks.forEach {
    if (it.state.skipped) {
      if (!wereTasksSkipped) {
        it.logger.lifecycle("\nSkipped tasks:")
        wereTasksSkipped = true
      }
      it.logger.lifecycle("‚è≠Ô∏è  :${it.name} (${it.state.skipMessage})")
    }
  }
}
afterEvaluate {
  // use Javadoc generated by Dokka
  tasks["publishPluginJavaDocsJar"].dependsOn.remove(tasks["javadoc"])
  tasks.withType(Jar::class.java)["publishPluginJavaDocsJar"].from(tasks["dokka"])
}

repositories {
  jcenter()
}

// Reuse the kotlin sources from the "buildSrc" project
gradle.projectsEvaluated {
  // the following line is here so IntelliJ correctly picks up the dependency on project :buildSrc
  sourceSets["main"].compileClasspath += project(":buildSrc").sourceSets["main"].output
  sourceSets["main"].withConvention(KotlinSourceSet::class) {
    project(":buildSrc").sourceSets["main"]
      .withConvention(KotlinSourceSet::class) { kotlin.srcDirs }
      .forEach {
        this.kotlin.srcDir(it)
      }
  }
  project(":buildSrc").configurations["implementation"].dependencies.forEach {
    // Add all `implementation` dependencies of the `buildSrc` project
    dependencies.implementation(it)
  }
}

dependencies {
  val junitVersion = "5.3.1"
  val kotlinVersion: String by project.project(":buildSrc").extra

  implementation(localGroovy())
  implementation(kotlin("stdlib-jdk8", kotlinVersion))
  testImplementation("org.junit.jupiter", "junit-jupiter-api", junitVersion)
  testRuntimeOnly("org.junit.jupiter", "junit-jupiter-engine", junitVersion)
}

jacoco {
  toolVersion = "0.8.1"
}
tasks.withType(JacocoReport::class.java) {
  reports {
    csv.isEnabled = true
  }
  val task = this
  doLast {
    val allLines = task.reports.csv.destination.readLines()
    val headerLine = allLines[0].split(',')
    var instructionsCovered = 0
    var instructionsMissed = 0
    var branchesCovered = 0
    var branchesMissed = 0
    var linesCovered = 0
    var linesMissed = 0
    allLines.subList(1, allLines.size)
      .map{ it.split(',') }
      .forEach {
        require(it.size == headerLine.size)
        instructionsCovered += it[headerLine.indexOf("INSTRUCTION_COVERED")].toInt()
        instructionsMissed += it[headerLine.indexOf("INSTRUCTION_MISSED")].toInt()
        branchesCovered += it[headerLine.indexOf("BRANCH_COVERED")].toInt()
        branchesMissed += it[headerLine.indexOf("BRANCH_MISSED")].toInt()
        linesCovered += it[headerLine.indexOf("LINE_COVERED")].toInt()
        linesMissed += it[headerLine.indexOf("LINE_MISSED")].toInt()
      }

    fun coverageLogMessage(coveredCount: Int, missedCount: Int) = "${String.format(Locale.UK, "%.4f", 100 * coveredCount.toDouble() / (coveredCount + missedCount))} % ($coveredCount of ${coveredCount + missedCount})"

    logger.lifecycle("Instruction coverage: ${coverageLogMessage(instructionsCovered, instructionsMissed)}")
    logger.lifecycle("     Branch coverage: ${coverageLogMessage(branchesCovered, branchesMissed)}")
    logger.lifecycle("       Line coverage: ${coverageLogMessage(linesCovered, linesMissed)}")
  }
}


tasks.withType(Test::class.java) {
  useJUnitPlatform()
  finalizedBy(tasks.getByName("jacocoTestReport"))
}

tasks {
  "dokka"(DokkaTask::class) {
    outputFormat = "html"
    outputDirectory = "$buildDir/docs/kdoc"
    gradle.projectsEvaluated {
      project(":buildSrc").sourceSets["main"].withConvention(KotlinSourceSet::class) {
        kotlin.srcDirs.forEach {
          sourceDirs = sourceDirs.toList().plus(it).asIterable()
        }
      }
    }
  }
  withType(DokkaTask::class.java) {
    includes = listOfNotNull("src/main/kotlin/packages.md")
    jdkVersion = 8
    skipEmptyPackages = false

    externalDocumentationLinks.add(DokkaConfiguration.ExternalDocumentationLink.Builder(URL("https://docs.gradle.org/${project.gradle.gradleVersion}/javadoc/")).build())
    externalDocumentationLinks.add(DokkaConfiguration.ExternalDocumentationLink.Builder(URL("http://docs.groovy-lang.org/${GroovySystem.getVersion()}/html/api/")).build())
  }
}

group = "org.openstreetmap.josm"

val tmpVersion = GitDescriber(projectDir).describe()
version = if (tmpVersion[0] == 'v') tmpVersion.substring(1) else tmpVersion

// for the plugin-publish (publish to plugins.gradle.org)
pluginBundle {
  website = "https://gitlab.com/floscher/gradle-josm-plugin#readme"
  vcsUrl = "https://gitlab.com/floscher/gradle-josm-plugin.git"
  description = "This plugin helps with developing for the JOSM project."
  tags = listOf("josm", "openstreetmap", "osm")

  plugins.create("josmPlugin") {
    id = project.group.toString()
    displayName = "Gradle JOSM plugin"
  }
}
// for the java-gradle-plugin (local publishing)
gradlePlugin {
  plugins.create("josmPlugin") {
    id = project.group.toString()
    implementationClass = "org.openstreetmap.josm.gradle.plugin.JosmPlugin"
  }
}

publishing {
  repositories {
    maven {
      setUrl("$buildDir/maven")
    }
  }
}
tasks {
  "publish" {
    description = "Deploys the gradle-josm-plugin to a local Maven repository inside the $buildDir"
    doLast {
      logger.lifecycle("Version {} is now deployed to {}", project.version.toString(), publishing.repositories.withType(MavenArtifactRepository::class.java)[0].url)
    }
  }
}

eclipse.project {
  natures(
    "org.eclipse.buildship.core.gradleprojectnature",
    "org.eclipse.jdt.core.javanature",
    "org.jetbrains.kotlin.core.kotlinNature"
  )
  buildCommand("org.eclipse.buildship.core.gradleprojectbuilder")
  buildCommand("org.eclipse.jdt.core.javabuilder")
  buildCommand("org.jetbrains.kotlin.ui.kotlinBuilder")
}
